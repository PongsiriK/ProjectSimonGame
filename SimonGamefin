#define STM32F411xE
#include "stm32f4xx.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>

// ค่าคงที่สำหรับเซนเซอร์แสง
#define VREF 3.3f
#define VCC 3.3f
#define ADC_MAXRES 4095.0f
#define RX 10000.0f
#define SLOPE -0.6875f
#define OFFSET 5.1276f

// ค่าคงที่สำหรับเซนเซอร์อุณหภูมิ
#define R0 10000.0f
#define T0 298.15f
#define BETA 3950.0f

uint8_t D18_value = 0;
uint8_t D100_value = 0;
uint8_t rounds = 0;
uint8_t previous_arr[100];
uint8_t present_arr[100];
uint8_t ans_arr[100];
uint32_t seed = 0;
uint8_t difficulty;
uint32_t difficulty_delay;
// Event tracking
uint8_t event_active = 0;
uint8_t current_event = 0;

uint8_t game_state = 1; // 1: idle, 2: set difficulty, 3: playing, 4: paused, 5: summary

void UART2_SendString(char *str) {
    for (int i = 0; str[i] != '\0'; i++) {
        while(!(USART2->SR & USART_SR_TXE));
        USART2->DR = str[i];
    }
}


int __io_putchar(int ch) {
    // รอให้ TXE พร้อม
    while(!(USART2->SR & USART_SR_TXE));
    // ส่งตัวอักษรออก
    USART2->DR = (ch & 0xFF);
    return ch;
}

char UART2_GetChar(void) {
    while(!(USART2->SR & USART_SR_RXNE)); // รอจนมีข้อมูล
    return (char)(USART2->DR & 0xFF);
}

uint8_t UART2_Available(void) {
    return (USART2->SR & USART_SR_RXNE) ? 1 : 0;
}

int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++) {
        __io_putchar(ptr[i]);
    }
    return len;
}

void my_delay(uint32_t TRESHOLD){
	   const uint32_t TH = (16000000 * (TRESHOLD / 1000)) / 12;
	    for (uint32_t i = 0; i < TH; i++);
}

uint32_t seed_from_temp(void) {
    ADC1->CR2 |= ADC_CR2_SWSTART;   // เริ่ม conversion
    // รอจนกว่าจะเสร็จ
    while (!(ADC1->SR & ADC_SR_EOC));

    // อ่านค่า
    return ADC1->DR;
}

void init_srng() {
	for (int i=0; i<8; i++) {
	    seed ^= seed_from_temp();
	}
	srand(seed);
}

uint8_t D18() {
	D18_value = rand() % 18; //0-17
	return D18_value;
}

uint8_t chance_checker(uint8_t CHANCE) {
	D100_value = rand() % 100;
	if (D100_value <= CHANCE) {
		return 1;
	}else{
		return 0;
	}
}

uint8_t event_rand(){
	D100_value = rand() % 100;
	if (D100_value >= 0 && D100_value <= 9){
		return 1;
	}else if (D100_value >= 10 && D100_value <= 20){
		return 2;
	}else if (D100_value >= 21 && D100_value <= 30){
		return 3;
	}else{
		return 0;
	}
}

uint32_t read_light_sensor(){
    ADC1->SQR3 = 1;
    ADC1->CR2 |= ADC_CR2_SWSTART;
    while((ADC1->SR & ADC_SR_EOC) == 0);
    return ADC1->DR;
}

uint32_t read_temp_sensor(){
    ADC1->SQR3 = 0;
    ADC1->CR2 |= ADC_CR2_SWSTART;
    while((ADC1->SR & ADC_SR_EOC) == 0);
    return ADC1->DR;
}

uint8_t night_event(){
    printf("* [EVENT] Night Mode Activated! Wait for light > 50 Lux ***\n");
	event_active = 1;
    uint32_t light_base = read_light_sensor();
	while(1){
		 GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7;
		GPIOB->BSRR = GPIO_BSRR_BS6;
		play_note(800, 100);
		GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7;
		GPIOB->BSRR = GPIO_BSRR_BR6;
		my_delay(500);
		uint32_t light_value = read_light_sensor();
        printf("[DEBUG] Light ADC = %lu (target: < 2000)\n", light_value);

        if (light_value < light_base - 1000){
            printf("* [EVENT] Night Mode Cleared! ***\n");
            event_active = 0;
            return 0;
        }
        my_delay(500);
	}
}

uint8_t winter_event(){
    printf("* [EVENT] Winter Mode Activated! Wait for temp > 30 C ***\n");

    event_active = 1;
     uint32_t temp_con = read_temp_sensor();
    while(1){
    	 GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7;
		GPIOB->BSRR = GPIO_BSRR_BS6;
		play_note(600, 100);
		my_delay(500);
		GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7;
		GPIOB->BSRR = GPIO_BSRR_BR6;

        uint32_t temp_value = read_temp_sensor();
        printf("[DEBUG] Temp ADC = %lu (need > %lu)\n", temp_value, temp_con + 10);

        if (temp_value > temp_con + 10){
            printf("* [EVENT] Winter Mode Cleared! ***\n");
            event_active = 0;
            return 0;
        }

        my_delay(500);
    }
}

uint8_t summer_event(){
    printf("* [EVENT] Summer Mode Activated! Wait for temp < 25 C ***\n");

    event_active = 1;
    uint32_t temp_con = read_temp_sensor();
    while(1){
    	GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7;
		GPIOB->BSRR = GPIO_BSRR_BS6;
		play_note(400, 100);
		my_delay(500);
		GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7;
		GPIOB->BSRR = GPIO_BSRR_BR6;

        uint32_t temp_value = read_temp_sensor();
        printf("[DEBUG] Temp ADC = %lu (need < %lu)\n", temp_value, temp_con - 10);

        if (temp_value < temp_con - 10){
            printf("* [EVENT] Summer Mode Cleared! ***\n");
            event_active = 0;
            return 0;
        }
        my_delay(500);
    }
}


uint8_t event_check(uint8_t event_value){
    switch (event_value){
    case 1:
        night_event();
        break;
    case 2:
        winter_event();
        break;
    case 3:
        summer_event();
        break;
    default:
        break;
    }
    return 0;
}


void fill_arr(uint8_t* arr, uint8_t value) {
	arr[rounds-1] = value;
}


void play_note(uint16_t frequency, uint16_t duration_ms) {
        if (frequency == 0) {
            // Silence - just delay
            for (volatile uint32_t i = 0; i < duration_ms * 1000; i++);
            return;
        }

        uint32_t half_period = 500000 / frequency;  // Half period in microseconds
        uint32_t cycles = (frequency * duration_ms) / 1000;

        for (uint32_t i = 0; i < cycles; i++) {
            GPIOB->BSRR = (1U << GPIO_BSRR_BS13_Pos);  // PB13 high
            for (volatile uint32_t j = 0; j < half_period; j++);

            GPIOB->BSRR = (1U << GPIO_BSRR_BR13_Pos);  // PB13 low
            for (volatile uint32_t j = 0; j < half_period; j++);
        }
    }
void display_a_light(uint8_t value){
    GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
    GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
    GPIOC->BSRR = GPIO_BSRR_BR7;
    switch (value)
    {
    case  0:
        printf("BLUE ");
        GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7 | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(261,difficulty_delay);
        break;
    case  1:
        printf("RED ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BS6 | GPIO_BSRR_BR7 | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(277,difficulty_delay);
        break;
    case  2:
        printf("YELLOW ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BS7 | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(293,difficulty_delay);
        break;
    case  3:
        printf("GREEN ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7 | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(311,difficulty_delay);
        break;
    case  4:
        printf("0 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(329,difficulty_delay);
        break;
    case  5:
        printf("1 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7 | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        play_note(349,difficulty_delay);
        break;
    case  6:
        printf("2 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(370,difficulty_delay);
        break;
    case  7:
        printf("3 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        play_note(392,difficulty_delay);
        break;
    case  8:
        printf("4 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(415,difficulty_delay);
        break;
    case  9:
        printf("5 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        play_note(440,difficulty_delay);
        break;
    case  10:
        printf("6 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(466,difficulty_delay);
        break;
    case  11:
        printf("7 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        play_note(493,difficulty_delay);
        break;
    case  12:
        printf("8 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(523,difficulty_delay);
        break;
    case  13:
        printf("9 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        play_note(554,difficulty_delay);
        break;
    case 14:
        printf("Up ");
        GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7  | GPIO_BSRR_BR8 | GPIO_BSRR_BS9;
        GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(587,difficulty_delay);
        break;
    case 15:
        printf("Down ");
        GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(622,difficulty_delay);
        break;
    case 16:
        printf("Left ");
        GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7  | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(659,difficulty_delay);
        break;
    case 17:
        printf("Right ");
        GPIOA->BSRR = GPIO_BSRR_BS5 | GPIO_BSRR_BS6 | GPIO_BSRR_BS7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        play_note(698,difficulty_delay);
        break;
    default:
        break;
    }
}


uint32_t ADC1_Read(uint16_t channel) {
    ADC1->SQR3 = channel;
    ADC1->CR2 |= ADC_CR2_SWSTART;   // เริ่ม conversion
    while(!(ADC1->SR & ADC_SR_EOC));
    return ADC1->DR;
}

uint32_t ADC1_avg (uint16_t channel){
	uint32_t sum=0;
	for(int i=0;i<6;i++){
		sum += ADC1_Read(channel);
		my_delay(2);
	}
	return sum/5;
}

uint8_t read_buttons(void) {
    if ((GPIOA->IDR & GPIO_IDR_ID10) == 0) {
        printf("[DEBUG] Button pressed: BLUE (Board Button PA10)\n");
        display_a_light(0);
        return 0;
    }
    if ((GPIOB->IDR & GPIO_IDR_ID3) == 0) {
        printf("[DEBUG] Button pressed: RED (Board Button PB3)\n");
        display_a_light(1);
        return 1;
    }
    if ((GPIOB->IDR & GPIO_IDR_ID5) == 0) {
        printf("[DEBUG] Button pressed: YELLOW (Board Button PB5)\n");
        display_a_light(2);
        return 2;
    }
    if ((GPIOB->IDR & GPIO_IDR_ID4) == 0) {
        printf("[DEBUG] Button pressed: GREEN (Board Button PB4)\n");
        display_a_light(3);
        return 3;
    }
    if(USART2->SR & USART_SR_RXNE) {
        char c = UART2_GetChar();
        printf("[DEBUG] UART input: '%c'\n", c);
        switch(c) {
            case '0':
            	display_a_light(4);
            	return 4;
            case '1': display_a_light(5); return 5;
            case '2': display_a_light(6); return 6;
            case '3': display_a_light(7); return 7;
            case '4': display_a_light(8); return 8;
            case '5': display_a_light(9); return 9;
            case '6': display_a_light(10); return 10;
            case '7': display_a_light(11); return 11;
            case '8': display_a_light(12); return 12;
            case '9': display_a_light(13); return 13;
            default: return 254;
        }
    };

    uint32_t x = ADC1_avg(12);
    uint32_t y = ADC1_avg(13);

    if(x > 2900) {
        printf("[DEBUG] Joystick: LEFT (x=%lu)\n", x);
        display_a_light(16);
        return 16;
    }
    else if(x < 300) {
        printf("[DEBUG] Joystick: RIGHT (x=%lu)\n", x);
        display_a_light(17);
        return 17;
    }

    if(y > 2900) {
        printf("[DEBUG] Joystick: DOWN (y=%lu)\n", y);
        display_a_light(15);
        return 15;
    }
    else if(y < 300) {
        printf("[DEBUG] Joystick: UP (y=%lu)\n", y);
        display_a_light(14);
        return 14;
    }

    return 255;
}


uint8_t check_answer(uint8_t* question, uint8_t rounds) {
    uint32_t index = 0;

    while (index < rounds) {
        uint8_t answer = read_buttons();

        if (answer != 255) {
        	my_delay(200); // ดีเลย์ป้องกันการกดซ้ำ
            if (question[index] == answer) {
                index++; // กดถูก → รอปุ่มถัดไป
                printf("[ANSWER] Correct! (%d/%d)\n", index, rounds);

                // รอจนผู้ใช้ปล่อยปุ่มก่อนรับครั้งถัดไป
                while (read_buttons() != 255);
            } else {
				printf("[ANSWER] Wrong! Expected: %d, Got: %d\n", question[index], answer);
                printf("========================================\n");
                printf("* GAME OVER! You reached Round %d ***\n", rounds);
                printf("========================================\n");
				return 1; // ❌ จบเกม
            }
        }
    }

    printf("[ANSWER] * Round %d cleared! All correct! ***\n\n", rounds);
    return 0; // ✅ ผ่านรอบนี้
}

display_7seg(uint8_t number){
    switch (number)
    {
    case  1:
        printf("1 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7 | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        break;
    case  2:
        printf("2 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        break;
    case  3:
        printf("3 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
        GPIOC->BSRR = GPIO_BSRR_BS7;
        break;
    case  4:
        printf("4 ");
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BR8 | GPIO_BSRR_BR9;
        GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BS10;
        GPIOC->BSRR = GPIO_BSRR_BR7;
        break;
    }
}

void difficulty_setting(){
    while (1)
    {
        // อ่านค่า potentiometer (Channel 4 - PA4)
        uint32_t pot_value = ADC1_Read(4);
        difficulty = (pot_value / 820) + 1; // 0-4095 -> 1-5
        if(difficulty > 5) difficulty = 5;
        if(difficulty < 1) difficulty = 1;

        // แสดงบน 7-segment
        display_7seg(difficulty);

        printf("[DIFFICULTY] Level: %d\n", difficulty);
        if (UART2_Available()) {
            char c = UART2_GetChar();
            if (c == 's' || c == '\n' || c == 'S') {
                printf("\n========================================\n");
                printf("State 3: Game Start (Difficulty: %d)\n", difficulty);
                printf("Press 'p' to pause\n");
                printf("========================================\n\n");
                difficulty_delay = 1800 / difficulty; // ตั้ง delay ตามความยาก
                return;
            }
        }
    }
}

void display_light(uint8_t* arr, uint32_t difficulty_delay){
	printf("[GAME] Displaying sequence for Round %d: ", rounds);
	for (uint8_t i=0;i<rounds;i++){
        display_a_light(arr[i]);
        my_delay(difficulty_delay);
        GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7  | GPIO_BSRR_BS8 | GPIO_BSRR_BS9;
		GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
		GPIOC->BSRR = GPIO_BSRR_BR7;
	}
	printf("\n");
}



void init_device() {
	//Clock setup
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;
		RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
		RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

		//Set gpio
		GPIOA->MODER &= ~(GPIO_MODER_MODER0 |GPIO_MODER_MODER1 |GPIO_MODER_MODER2 | GPIO_MODER_MODER4 | GPIO_MODER_MODER5 | GPIO_MODER_MODER6 | GPIO_MODER_MODER7 | GPIO_MODER_MODER8 | GPIO_MODER_MODER9 | GPIO_MODER_MODER10);
		GPIOA->MODER |= (0b01 << GPIO_MODER_MODER5_Pos)
					  | (0b01 << GPIO_MODER_MODER6_Pos)
					  | (0b01 << GPIO_MODER_MODER7_Pos)
					  | (0b01 << GPIO_MODER_MODER8_Pos)
					  | (0b01 << GPIO_MODER_MODER9_Pos)
					  | (0b11 << GPIO_MODER_MODER2_Pos)
                      | (0b11 << GPIO_MODER_MODER4_Pos)
                      | (0b11 << GPIO_MODER_MODER0_Pos)
                      | (0b11 << GPIO_MODER_MODER1_Pos);
		GPIOA->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED5 | GPIO_OSPEEDR_OSPEED6 | GPIO_OSPEEDR_OSPEED7 | GPIO_OSPEEDR_OSPEED8 | GPIO_OSPEEDR_OSPEED9);
		GPIOA->OTYPER &= ~(GPIO_OTYPER_OT_5 | GPIO_OTYPER_OT_6 | GPIO_OTYPER_OT_7 | GPIO_OTYPER_OT_8 | GPIO_OTYPER_OT_9);
		GPIOB->MODER &= ~(GPIO_MODER_MODER6 | GPIO_MODER_MODER10 | GPIO_MODER_MODER13 | GPIO_MODER_MODER3 | GPIO_MODER_MODER5 | GPIO_MODER_MODER4);
		GPIOB->MODER |= (0b01 << GPIO_MODER_MODER6_Pos)
						| (0b01 << GPIO_MODER_MODER10_Pos)
						| (0b01 << GPIO_MODER_MODER13_Pos);
		GPIOB->OTYPER &= ~(GPIO_OTYPER_OT6 | GPIO_OTYPER_OT10);
		GPIOB->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED6 | GPIO_OSPEEDR_OSPEED10);
		GPIOC->MODER &= ~(GPIO_MODER_MODER7 | GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
		GPIOC->MODER |= (0b01 << GPIO_MODER_MODER7_Pos)
					  | (0b11 << GPIO_MODER_MODER2_Pos)
					  | (0b11 << GPIO_MODER_MODER3_Pos);
		GPIOC->OTYPER &= ~(GPIO_OTYPER_OT7);
		GPIOC->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED7);
		GPIOA->PUPDR &= ~GPIO_PUPDR_PUPD10;
		GPIOA->PUPDR |= (0b01 << GPIO_PUPDR_PUPD10_Pos);
		GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPD3 | GPIO_PUPDR_PUPD4 | GPIO_PUPDR_PUPD5);
		GPIOB->PUPDR |= (0b01 << GPIO_PUPDR_PUPD3_Pos)
					  | (0b01 << GPIO_PUPDR_PUPD4_Pos)
					  | (0b01 << GPIO_PUPDR_PUPD5_Pos);



		GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
		GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos)
					  | (0b10 << GPIO_MODER_MODER3_Pos);
		GPIOA->AFR[0] |= (0x7 << (4*2)) | (0x7 << (4*3));

		USART2->BRR = 139; // 115200 @16MHz
		USART2->CR1 |= USART_CR1_UE | USART_CR1_RE | USART_CR1_TE;

		// เลือก channel 0 (PA0)
	    ADC1->SQR1 = 0; // 1 conversion
		ADC1->SQR3 = 0;    // ช่องแรกเป็น CH0
		ADC1->CR2 |= ADC_CR2_ADON;

	 // Enable FPU for floating point calculations
		SCB->CPACR |= (0b1111 << 20);
		__asm volatile("dsb");
		__asm volatile("isb");


}



int main(void)
{
    init_device();
    init_srng();

    printf("\n========================================\n");
    printf("===  SIMON GAME - State Machine     ===\n");
    printf("========================================\n");
    printf("State 1: Press 's' to start\n");
    printf("========================================\n\n");

    while(1){
        switch(game_state){

        case 1: // ========== STATE: IDLE ==========
            if(UART2_Available()){
                char c = UART2_GetChar();
                printf("[DEBUG] Input: '%c'\n", c);
                if(c == 's'){
                    printf("\n========================================\n");
                    printf("State 2: Setting Difficulty\n");
                    printf("Turn potentiometer, then press 's'\n");
                    printf("========================================\n\n");
                    game_state = 2;
                }
            }
            my_delay(100);
            break;

        case 2: // ========== STATE: SET DIFFICULTY ==========
                difficulty_setting();
                rounds = 0;
                game_state = 3;
                my_delay(200);
            break;

        case 3: // ========== STATE: PLAYING ==========
            rounds++;

            if(rounds > 5){
                // ชนะเกม!
                game_state = 5;
                break;
            }

            printf("\n========================================\n");
            printf("           ROUND %d                     \n", rounds);
            printf("========================================\n");

            // สุ่ม Event
            uint8_t event = event_rand();
            if (event == 0) {
                printf("[RANDOM] No event\n");
            } else {
                printf("[RANDOM] Event: %d\n", event);
                uint8_t event_result = event_check(event);
                if(event_result == 255){
                    // ถูก pause ระหว่าง event
                    game_state = 4;
                    rounds--; // ยังไม่เล่นรอบนี้
                    break;
                }
            }

            // สุ่มไฟ
            if (rounds == 1) {
                uint8_t new_val = D18();
                fill_arr(present_arr, new_val);
                printf("[RANDOM] New: %d\n", new_val);
            } else {
                for (uint8_t i = 0; i < rounds - 1; i++) {
                    present_arr[i] = previous_arr[i];
                }
                uint8_t new_val = D18();
                fill_arr(present_arr, new_val);
                printf("[RANDOM] New: %d\n", new_val);
            }

            // แสดงไฟ
            my_delay(1000);
            display_light(present_arr, difficulty_delay);

            // รอคำตอบ
            my_delay(1000);
            uint8_t result = check_answer(present_arr, rounds);

            if (result == 1) {
                // ตอบผิด -> สรุปผล
                printf("\n*** GAME OVER ***\n");
                game_state = 5;
            } else if (result == 255){
                // กด pause
                game_state = 4;
            } else {
                // ตอบถูก -> รอบถัดไป
                for (uint8_t i = 0; i < rounds; i++) {
                    previous_arr[i] = present_arr[i];
                }
                printf("[GAME] Next round...\n");
                my_delay(1500);
            }
            break;

        case 4: // ========== STATE: PAUSED ==========
            printf("\n========================================\n");
            printf("           GAME PAUSED                  \n");
            printf("========================================\n");
            printf("Press 'p' to resume\n");
            printf("Press 'e' to exit game\n");
            printf("========================================\n\n");

            // ปิดไฟทั้งหมด
            GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7;
            GPIOB->BSRR = GPIO_BSRR_BR6 | GPIO_BSRR_BR10;
            GPIOC->BSRR = GPIO_BSRR_BR7;

            while(game_state == 4){
                if(UART2_Available()){
                    char c = UART2_GetChar();
                    printf("[DEBUG] Input: '%c'\n", c);

                    if(c == 'p'){
                        printf("\n========================================\n");
                        printf("           GAME RESUMED                 \n");
                        printf("========================================\n\n");
                        game_state = 3;

                        // แสดงไฟอีกครั้ง
                        my_delay(1000);
                        printf("[GAME] Showing sequence again...\n");
                        display_light(present_arr,difficulty_delay);

                        // กลับไปรอคำตอบต่อ
                        my_delay(1000);
                        uint8_t result = check_answer(present_arr, rounds);

                        if (result == 1) {
                            printf("\n*** GAME OVER ***\n");
                            game_state = 5;
                        } else if (result == 255){
                            game_state = 4; // pause อีก
                        } else {
                            // ตอบถูก
                            for (uint8_t i = 0; i < rounds; i++) {
                                previous_arr[i] = present_arr[i];
                            }
                            printf("[GAME] Next round...\n");
                            my_delay(1500);
                            // game_state ยังคงเป็น 3 อยู่แล้ว
                        }

                    } else if(c == 'e'){
                        printf("\n========================================\n");
                        printf("           GAME EXITED                  \n");
                        printf("========================================\n\n");
                        game_state = 1;
                        rounds = 0;
                        printf("State 1: Press 's' to start\n");
                    }
                }
                my_delay(100);
            }
            break;

        case 5: // ========== STATE: SUMMARY ==========
            printf("\n========================================\n");
            printf("           GAME SUMMARY                 \n");
            printf("========================================\n");

            if(rounds > 5){
                printf("* CONGRATULATIONS! ***\n");
                printf("You win!\n");
                printf("Difficulty: %d\n", difficulty);

                // เล่นเสียงชนะ
                play_note(523, 200);
                play_note(587, 200);
                play_note(659, 200);
                play_note(784, 400);

            } else {
                printf("Final Score: Round %d\n", rounds);
                printf("Difficulty: %d\n", difficulty);

                // เล่นเสียงแพ้
                play_note(200, 500);
                play_note(150, 500);
                play_note(100, 1000);
            }

            printf("========================================\n");
            printf("Press 's' to play again\n");
            printf("========================================\n\n");

            // รอคำสั่ง
            while(game_state == 5){
                if(UART2_Available()){
                    char c = UART2_GetChar();
                    printf("[DEBUG] Input: '%c'\n", c);

                    if(c == 's'){
                        printf("\n========================================\n");
                        printf("State 2: Setting Difficulty\n");
                        printf("Turn potentiometer, then press 's'\n");
                        printf("========================================\n\n");
                        rounds = 0;
                        game_state = 2;
                    }
                }
                my_delay(100);
            }
            break;

        default:
            game_state = 1;
            break;
        }
    }
}


